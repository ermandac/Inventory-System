{"ast":null,"code":"import { of, EMPTY } from 'rxjs';\nimport { concatMap, withLatestFrom, tap, catchError, finalize } from 'rxjs/operators';\n\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nfunction concatLatestFrom(observablesFactory) {\n  return concatMap(value => {\n    const observables = observablesFactory(value);\n    const observablesAsArray = Array.isArray(observables) ? observables : [observables];\n    return of(value).pipe(withLatestFrom(...observablesAsArray));\n  });\n}\n\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate. It enforces that the error case is handled and\n * that the effect would still be running should an error occur.\n *\n * Takes optional callbacks for `complete` and `finalize`.\n *\n * @usageNotes\n *\n * ```ts\n * readonly dismissAlert = this.effect<Alert>((alert$) => {\n *   return alert$.pipe(\n *     concatMap(\n *       (alert) => this.alertsService.dismissAlert(alert).pipe(\n *         tapResponse(\n *           (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *           (error: { message: string }) => this.logError(error.message)\n *         )\n *       )\n *     )\n *   );\n * });\n *\n * readonly loadUsers = this.effect<void>((trigger$) => {\n *   return trigger$.pipe(\n *     tap(() => this.patchState({ loading: true })),\n *     exhaustMap(() =>\n *       this.usersService.getAll().pipe(\n *         tapResponse({\n *           next: (users) => this.patchState({ users }),\n *           error: (error: HttpErrorResponse) => this.logError(error.message),\n *           finalize: () => this.patchState({ loading: false }),\n *         })\n *       )\n *     )\n *   );\n * });\n * ```\n */\nfunction tapResponse(observerOrNext, error, complete) {\n  const observer = typeof observerOrNext === 'function' ? {\n    next: observerOrNext,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    error: error,\n    complete\n  } : observerOrNext;\n  return source => source.pipe(tap({\n    next: observer.next,\n    complete: observer.complete\n  }), catchError(error => {\n    observer.error(error);\n    return EMPTY;\n  }), observer.finalize ? finalize(observer.finalize) : source$ => source$);\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { concatLatestFrom, tapResponse };","map":{"version":3,"names":["of","EMPTY","concatMap","withLatestFrom","tap","catchError","finalize","concatLatestFrom","observablesFactory","value","observables","observablesAsArray","Array","isArray","pipe","tapResponse","observerOrNext","error","complete","observer","next","source","source$"],"sources":["/home/kryogenic/Desktop/Development-Projects/Inventory-System/node_modules/@ngrx/operators/fesm2022/ngrx-operators.mjs"],"sourcesContent":["import { of, EMPTY } from 'rxjs';\nimport { concatMap, withLatestFrom, tap, catchError, finalize } from 'rxjs/operators';\n\n/**\n * `concatLatestFrom` combines the source value\n * and the last available value from a lazily evaluated Observable\n * in a new array\n *\n * @usageNotes\n *\n * Select the active customer from the NgRx Store\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * as fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom(() => this.store.select(fromCustomers.selectActiveCustomer))\n * )\n * ```\n *\n * Select a customer from the NgRx Store by its id that is available on the action\n *\n * ```ts\n * import { concatLatestFrom } from '@ngrx/effects';\n * import * fromCustomers from '../customers';\n *\n * this.actions$.pipe(\n *  concatLatestFrom((action) => this.store.select(fromCustomers.selectCustomer(action.customerId)))\n * )\n * ```\n */\nfunction concatLatestFrom(observablesFactory) {\n    return concatMap((value) => {\n        const observables = observablesFactory(value);\n        const observablesAsArray = Array.isArray(observables)\n            ? observables\n            : [observables];\n        return of(value).pipe(withLatestFrom(...observablesAsArray));\n    });\n}\n\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate. It enforces that the error case is handled and\n * that the effect would still be running should an error occur.\n *\n * Takes optional callbacks for `complete` and `finalize`.\n *\n * @usageNotes\n *\n * ```ts\n * readonly dismissAlert = this.effect<Alert>((alert$) => {\n *   return alert$.pipe(\n *     concatMap(\n *       (alert) => this.alertsService.dismissAlert(alert).pipe(\n *         tapResponse(\n *           (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *           (error: { message: string }) => this.logError(error.message)\n *         )\n *       )\n *     )\n *   );\n * });\n *\n * readonly loadUsers = this.effect<void>((trigger$) => {\n *   return trigger$.pipe(\n *     tap(() => this.patchState({ loading: true })),\n *     exhaustMap(() =>\n *       this.usersService.getAll().pipe(\n *         tapResponse({\n *           next: (users) => this.patchState({ users }),\n *           error: (error: HttpErrorResponse) => this.logError(error.message),\n *           finalize: () => this.patchState({ loading: false }),\n *         })\n *       )\n *     )\n *   );\n * });\n * ```\n */\nfunction tapResponse(observerOrNext, error, complete) {\n    const observer = typeof observerOrNext === 'function'\n        ? {\n            next: observerOrNext,\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            error: error,\n            complete,\n        }\n        : observerOrNext;\n    return (source) => source.pipe(tap({ next: observer.next, complete: observer.complete }), catchError((error) => {\n        observer.error(error);\n        return EMPTY;\n    }), observer.finalize ? finalize(observer.finalize) : (source$) => source$);\n}\n\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { concatLatestFrom, tapResponse };\n"],"mappings":"AAAA,SAASA,EAAE,EAAEC,KAAK,QAAQ,MAAM;AAChC,SAASC,SAAS,EAAEC,cAAc,EAAEC,GAAG,EAAEC,UAAU,EAAEC,QAAQ,QAAQ,gBAAgB;;AAErF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,kBAAkB,EAAE;EAC1C,OAAON,SAAS,CAAEO,KAAK,IAAK;IACxB,MAAMC,WAAW,GAAGF,kBAAkB,CAACC,KAAK,CAAC;IAC7C,MAAME,kBAAkB,GAAGC,KAAK,CAACC,OAAO,CAACH,WAAW,CAAC,GAC/CA,WAAW,GACX,CAACA,WAAW,CAAC;IACnB,OAAOV,EAAE,CAACS,KAAK,CAAC,CAACK,IAAI,CAACX,cAAc,CAAC,GAAGQ,kBAAkB,CAAC,CAAC;EAChE,CAAC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,WAAWA,CAACC,cAAc,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EAClD,MAAMC,QAAQ,GAAG,OAAOH,cAAc,KAAK,UAAU,GAC/C;IACEI,IAAI,EAAEJ,cAAc;IACpB;IACAC,KAAK,EAAEA,KAAK;IACZC;EACJ,CAAC,GACCF,cAAc;EACpB,OAAQK,MAAM,IAAKA,MAAM,CAACP,IAAI,CAACV,GAAG,CAAC;IAAEgB,IAAI,EAAED,QAAQ,CAACC,IAAI;IAAEF,QAAQ,EAAEC,QAAQ,CAACD;EAAS,CAAC,CAAC,EAAEb,UAAU,CAAEY,KAAK,IAAK;IAC5GE,QAAQ,CAACF,KAAK,CAACA,KAAK,CAAC;IACrB,OAAOhB,KAAK;EAChB,CAAC,CAAC,EAAEkB,QAAQ,CAACb,QAAQ,GAAGA,QAAQ,CAACa,QAAQ,CAACb,QAAQ,CAAC,GAAIgB,OAAO,IAAKA,OAAO,CAAC;AAC/E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAASf,gBAAgB,EAAEQ,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}